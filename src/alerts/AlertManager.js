const nodemailer = require('nodemailer');
const EventEmitter = require('events');

class NotificationManager extends EventEmitter {
  constructor(config, db) {
    super();
    this.config = config;
    this.db = db;
    this.emailTransporter = null;
    this.notificationQueue = [];
    this.isProcessingQueue = false;
    
    this.initializeEmailTransporter();
    this.startQueueProcessor();
  }

  initializeEmailTransporter() {
    const emailConfig = this.config.alerts?.notifications?.email;
    
    if (emailConfig && emailConfig.enabled && emailConfig.smtp) {
      try {
        this.emailTransporter = nodemailer.createTransporter({
          host: emailConfig.smtp.host,
          port: emailConfig.smtp.port,
          secure: emailConfig.smtp.secure,
          auth: emailConfig.smtp.auth
        });
        
        console.log('Email transporter initialized');
      } catch (error) {
        console.error('Failed to initialize email transporter:', error);
      }
    }
  }

  async sendEmail(recipients, subject, message, html = null) {
    if (!this.emailTransporter) {
      throw new Error('Email transporter not configured');
    }

    const mailOptions = {
      from: this.config.alerts?.notifications?.email?.from || 'phonebank-monitor@example.com',
      to: Array.isArray(recipients) ? recipients.join(', ') : recipients,
      subject,
      text: message,
      html: html || this.generateEmailHtml(subject, message)
    };

    try {
      const result = await this.emailTransporter.sendMail(mailOptions);
      console.log(`📧 Email sent successfully: ${subject}`);
      return { success: true, messageId: result.messageId };
    } catch (error) {
      console.error(`Failed to send email: ${error.message}`);
      throw error;
    }
  }

  generateEmailHtml(subject, message) {
    return `
    <!DOCTYPE html>
    <html>
    <head>
        <style>
            body { font-family: Arial, sans-serif; margin: 0; padding: 20px; background-color: #f5f5f5; }
            .container { max-width: 600px; margin: 0 auto; background-color: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
            .header { background-color: #dc3545; color: white; padding: 15px; border-radius: 4px; margin-bottom: 20px; }
            .content { line-height: 1.6; color: #333; }
            .footer { margin-top: 20px; padding-top: 15px; border-top: 1px solid #eee; font-size: 12px; color: #666; }
            .timestamp { font-style: italic; color: #888; }
        </style>
    </head>
    <body>
        <div class="container">
            <div class="header">
                <h2>🚨 Phonebank Alert</h2>
            </div>
            <div class="content">
                <h3>${subject}</h3>
                <pre style="white-space: pre-wrap; font-family: Arial, sans-serif;">${message}</pre>
                <p class="timestamp">Timestamp: ${new Date().toISOString()}</p>
            </div>
            <div class="footer">
                <p>This alert was generated by Phonebank Monitoring System</p>
                <p>Please do not reply to this email.</p>
            </div>
        </div>
    </body>
    </html>`;
  }

  async sendWebhook(url, data, method = 'POST', headers = {}) {
    try {
      const fetch = (await import('node-fetch')).default;
      
      const response = await fetch(url, {
        method,
        headers: {
          'Content-Type': 'application/json',
          ...headers
        },
        body: JSON.stringify(data)
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      console.log(`🔗 Webhook sent successfully to ${url}`);
      return { success: true, status: response.status };
    } catch (error) {
      console.error(`Failed to send webhook to ${url}:`, error.message);
      throw error;
    }
  }

  async sendSlackNotification(message, channel = null) {
    const slackConfig = this.config.alerts?.notifications?.slack;
    
    if (!slackConfig || !slackConfig.enabled || !slackConfig.webhookUrl) {
      throw new Error('Slack notification not configured');
    }

    const payload = {
      text: message,
      channel: channel || slackConfig.channel,
      username: 'Phonebank Monitor',
      icon_emoji: ':warning:'
    };

    return await this.sendWebhook(slackConfig.webhookUrl, payload);
  }

  async queueNotification(type, data) {
    this.notificationQueue.push({
      id: Date.now() + Math.random(),
      type,
      data,
      timestamp: new Date(),
      attempts: 0,
      maxAttempts: 3
    });

    if (!this.isProcessingQueue) {
      this.processQueue();
    }
  }

  async processQueue() {
    if (this.isProcessingQueue || this.notificationQueue.length === 0) {
      return;
    }

    this.isProcessingQueue = true;

    while (this.notificationQueue.length > 0) {
      const notification = this.notificationQueue.shift();
      
      try {
        await this.processNotification(notification);
        
        // Log successful notification
        if (notification.data.alertId) {
          await this.db.logEvent(
            'notification_sent',
            'info',
            `${notification.type} notification sent successfully`,
            { alertId: notification.data.alertId, type: notification.type }
          );
        }
        
      } catch (error) {
        console.error(`Failed to process notification:`, error);
        
        notification.attempts++;
        
        if (notification.attempts < notification.maxAttempts) {
          // Re-queue with exponential backoff
          setTimeout(() => {
            this.notificationQueue.push(notification);
          }, Math.pow(2, notification.attempts) * 1000);
        } else {
          console.error(`Max attempts reached for notification ${notification.id}`);
          
          // Log failed notification
          if (notification.data.alertId) {
            await this.db.logEvent(
              'notification_failed',
              'error',
              `Failed to send ${notification.type} notification after ${notification.maxAttempts} attempts`,
              { alertId: notification.data.alertId, type: notification.type, error: error.message }
            );
          }
        }
      }
    }

    this.isProcessingQueue = false;
  }

  async processNotification(notification) {
    const { type, data } = notification;

    switch (type) {
      case 'email':
        await this.sendEmail(data.recipients, data.subject, data.message, data.html);
        break;

      case 'webhook':
        await this.sendWebhook(data.url, data.payload, data.method, data.headers);
        break;

      case 'slack':
        await this.sendSlackNotification(data.message, data.channel);
        break;

      default:
        throw new Error(`Unknown notification type: ${type}`);
    }
  }

  startQueueProcessor() {
    // Process queue every 5 seconds
    setInterval(() => {
      if (!this.isProcessingQueue && this.notificationQueue.length > 0) {
        this.processQueue();
      }
    }, 5000);
  }
}

class AlertManager extends EventEmitter {
  constructor(config, db, notificationManager) {
    super();
    this.config = config;
    this.db = db;
    this.notificationManager = notificationManager;
    this.alertRules = new Map();
    this.alertCooldowns = new Map();
    this.thresholds = config.alerts?.thresholds || {};
    
    this.initializeAlertRules();
  }

  initializeAlertRules() {
    // Device offline alert
    this.alertRules.set('device_offline', {
      severity: 'high',
      cooldown: 5 * 60 * 1000, // 5 minutes
      condition: (data) => data.status === 'offline',
      message: (data) => `Device ${data.url} at ${data.location} is offline. Error: ${data.error}`
    });

    // High unauthorized connections
    this.alertRules.set('high_unauthorized', {
      severity: 'medium',
      cooldown: 10 * 60 * 1000, // 10 minutes
      condition: (data) => {
        const match = (data.unauthorized && typeof data.unauthorized === 'string') 
          ? data.unauthorized.match(/(\d+)/) 
          : null;
        const count = match ? parseInt(match[1]) : 0;
        return count > (this.thresholds.unauthorizedMax || 5);
      },
      message: (data) => `High unauthorized connections on ${data.url} at ${data.location}: ${data.unauthorized}`
    });

    // Slow response time
    this.alertRules.set('slow_response', {
      severity: 'low',
      cooldown: 15 * 60 * 1000, // 15 minutes
      condition: (data) => data.responseTime > (this.thresholds.responseTimeMax || 30000),
      message: (data) => `Slow response time on ${data.url} at ${data.location}: ${data.responseTime}ms`
    });

    // Location degradation
    this.alertRules.set('location_degradation', {
      severity: 'high',
      cooldown: 20 * 60 * 1000, // 20 minutes
      condition: (data) => data.degradationLevel === 'CRITICAL',
      message: (data) => `Critical degradation detected at ${data.location}. Multiple devices are offline.`
    });

    // System memory high
    this.alertRules.set('high_memory', {
      severity: 'medium',
      cooldown: 10 * 60 * 1000, // 10 minutes
      condition: (data) => parseFloat(data.memoryUsage) > 85,
      message: (data) => `High memory usage detected: ${data.memoryUsage}%`
    });
  }

  async checkAlerts(deviceData) {
    const alertsTriggered = [];

    for (const [ruleId, rule] of this.alertRules.entries()) {
      try {
        if (rule.condition(deviceData)) {
          const alertKey = `${ruleId}:${deviceData.url || 'system'}`;
          
          // Check cooldown
          if (this.isOnCooldown(alertKey, rule.cooldown)) {
            continue;
          }

          // Create alert
          const alert = await this.createAlert(ruleId, deviceData, rule);
          alertsTriggered.push(alert);
          
          // Set cooldown
          this.setCooldown(alertKey);
          
          // Send notifications
          await this.sendAlertNotifications(alert, deviceData);
        }
      } catch (error) {
        console.error(`Error checking alert rule ${ruleId}:`, error);
      }
    }

    return alertsTriggered;
  }

  async createAlert(ruleId, deviceData, rule) {
    try {
      const device = deviceData.url ? await this.db.getDevice(deviceData.url) : null;
      const deviceId = device ? device.id : null;
      
      const alertId = await this.db.createAlert(
        deviceId,
        ruleId,
        rule.severity,
        `${ruleId.replace('_', ' ').toUpperCase()} Alert`,
        rule.message(deviceData)
      );

      const alert = {
        id: alertId,
        ruleId,
        deviceId,
        severity: rule.severity,
        title: `${ruleId.replace('_', ' ').toUpperCase()} Alert`,
        message: rule.message(deviceData),
        timestamp: new Date().toISOString(),
        deviceData
      };

      console.log(`🚨 Alert created: ${alert.title} - ${alert.message}`);
      this.emit('alert-created', alert);
      
      return alert;
    } catch (error) {
      console.error('Failed to create alert:', error);
      throw error;
    }
  }

  async sendAlertNotifications(alert, deviceData) {
    const alertsConfig = this.config.alerts;
    
    if (!alertsConfig || !alertsConfig.enabled) {
      return;
    }

    const notifications = alertsConfig.notifications || {};

    // Email notifications
    if (notifications.email && notifications.email.enabled && notifications.email.recipients) {
      const subject = `🚨 ${alert.title} - ${deviceData.location || 'System'}`;
      const message = this.formatAlertMessage(alert, deviceData);
      
      await this.notificationManager.queueNotification('email', {
        recipients: notifications.email.recipients,
        subject,
        message,
        alertId: alert.id
      });
    }

    // Webhook notifications
    if (notifications.webhook && notifications.webhook.enabled && notifications.webhook.url) {
      const payload = {
        alert: {
          id: alert.id,
          title: alert.title,
          message: alert.message,
          severity: alert.severity,
          timestamp: alert.timestamp
        },
        device: deviceData,
        system: {
          environment: this.config.environment || 'development',
          timestamp: new Date().toISOString()
        }
      };

      await this.notificationManager.queueNotification('webhook', {
        url: notifications.webhook.url,
        payload,
        method: notifications.webhook.method || 'POST',
        headers: notifications.webhook.headers || {},
        alertId: alert.id
      });
    }

    // Slack notifications
    if (notifications.slack && notifications.slack.enabled && notifications.slack.webhookUrl) {
      const message = this.formatSlackMessage(alert, deviceData);
      
      await this.notificationManager.queueNotification('slack', {
        message,
        channel: notifications.slack.channel,
        alertId: alert.id
      });
    }
  }

  formatAlertMessage(alert, deviceData) {
    return `
Alert Details:
===================
Title: ${alert.title}
Severity: ${alert.severity.toUpperCase()}
Message: ${alert.message}
Timestamp: ${alert.timestamp}

Device Information:
===================
URL: ${deviceData.url || 'N/A'}
Location: ${deviceData.location || 'N/A'}
Priority: ${deviceData.priority || 'N/A'}
Status: ${deviceData.status || 'N/A'}
Response Time: ${deviceData.responseTime || 'N/A'}ms
Authorized: ${deviceData.authorized || 'N/A'}
Unauthorized: ${deviceData.unauthorized || 'N/A'}
Phonebank IP: ${deviceData.phonebankIp || 'N/A'}
Error: ${deviceData.error || 'None'}

System Information:
===================
Environment: ${this.config.environment || 'development'}
Alert ID: ${alert.id}
Rule ID: ${alert.ruleId}

Please check the dashboard for more details and take appropriate action.
    `.trim();
  }

  formatSlackMessage(alert, deviceData) {
    const severityEmoji = {
      low: '⚠️',
      medium: '🔶',
      high: '🚨'
    };

    return `${severityEmoji[alert.severity]} *${alert.title}*
*Location:* ${deviceData.location || 'System'}
*Device:* ${deviceData.url || 'System-wide'}
*Message:* ${alert.message}
*Timestamp:* ${alert.timestamp}`;
  }

  isOnCooldown(alertKey, cooldownMs) {
    const lastAlert = this.alertCooldowns.get(alertKey);
    if (!lastAlert) return false;
    
    return (Date.now() - lastAlert) < cooldownMs;
  }

  setCooldown(alertKey) {
    this.alertCooldowns.set(alertKey, Date.now());
  }

  async resolveAlert(alertId, resolvedBy = 'system') {
    try {
      await this.db.resolveAlert(alertId, resolvedBy);
      
      console.log(`Alert ${alertId} resolved by ${resolvedBy}`);
      this.emit('alert-resolved', { alertId, resolvedBy });
      
    } catch (error) {
      console.error(`Failed to resolve alert ${alertId}:`, error);
      throw error;
    }
  }

  async acknowledgeAlert(alertId, acknowledgedBy) {
    try {
      // Update alert acknowledgment in database
      const sql = `UPDATE alerts SET acknowledged_at = CURRENT_TIMESTAMP, acknowledged_by = ? WHERE id = ?`;
      await new Promise((resolve, reject) => {
        this.db.db.run(sql, [acknowledgedBy, alertId], (err) => {
          if (err) reject(err);
          else resolve();
        });
      });
      
      console.log(`Alert ${alertId} acknowledged by ${acknowledgedBy}`);
      this.emit('alert-acknowledged', { alertId, acknowledgedBy });
      
    } catch (error) {
      console.error(`Failed to acknowledge alert ${alertId}:`, error);
      throw error;
    }
  }

  // Auto-resolution for certain alert types
  async checkAutoResolution(deviceData) {
    try {
      const activeAlerts = await this.db.getActiveAlerts();
      
      for (const alert of activeAlerts) {
        let shouldResolve = false;
        
        switch (alert.alert_type) {
          case 'device_offline':
            // Resolve if device is back online
            if (alert.url === deviceData.url && deviceData.status === 'online') {
              shouldResolve = true;
            }
            break;
            
          case 'high_unauthorized':
            // Resolve if unauthorized count is back to normal
            if (alert.url === deviceData.url) {
              const match = (deviceData.unauthorized && typeof deviceData.unauthorized === 'string') 
                ? deviceData.unauthorized.match(/(\d+)/) 
                : null;
              const count = match ? parseInt(match[1]) : 0;
              if (count <= (this.thresholds.unauthorizedMax || 5)) {
                shouldResolve = true;
              }
            }
            break;
            
          case 'slow_response':
            // Resolve if response time is back to normal
            if (alert.url === deviceData.url && 
                deviceData.responseTime <= (this.thresholds.responseTimeMax || 30000)) {
              shouldResolve = true;
            }
            break;
        }
        
        if (shouldResolve) {
          await this.resolveAlert(alert.id, 'auto-resolution');
        }
      }
    } catch (error) {
      console.error('Error checking auto-resolution:', error);
    }
  }

  getAlertStats() {
    return {
      rulesCount: this.alertRules.size,
      activeCooldowns: this.alertCooldowns.size,
      thresholds: this.thresholds
    };
  }
}

module.exports = {
  NotificationManager,
  AlertManager
};